---
title: "Using caliper"
author: "Kyle Ward"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Using caliper}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

`caliper` makes it easy to work with Caliper software from R. Supported
software includes:

  * [TransCAD](https://www.caliper.com/tcovu.htm)
  * [TransModeler](https://www.caliper.com/transmodeler/default.htm)
  * [Maptitude](https://www.caliper.com/maptovu.htm)

The sections below show how to work with the package.

## Connecting

When you load the library, `caliper` will automatically find and connect to
installed Caliper software.

```{r}
library(caliper)
```

It does so using the `connect()` function. If you have multiple
software applications installed, you can call this directly to specify which you
want to connect to.

```{r}
# connect("Maptitude")
```

To close the connection (and the caliper software running in the background),
use `disconnect()`.

## Basic Macros/Functions

Caliper software comes with a scripting language called GISDK. In this language,
there is a difference between 'functions' and 'macros'. Functions are written in
C++ and are called directly in GISDK (e.g. `OpenTable()`). Macros are written in
GISDK, and are called using `RunMacro("macro name")`.

### Example 1: Running a macro {#ex1}

```{r}
folder <- RunMacro("G30 Tutorial Folder")
folder
```

This is the equivalent of writing `RunMacro("G30 Tutorial Folder")` in GISDK.

### Example 2: Running a function

To run a function from R, the format is slightly different from GISDK. Instead
of calling `OpenTable()` directly, use `RunFunction("OpenTable")`.

```{r}
table_name <- RunFunction("OpenTable", "airports", "ffb", list(paste0(folder, "airports.bin"), NA))
num_rows <- RunFunction("GetRecordCount", table_name, NA)
paste0("The table '", table_name, "' has ", num_rows, " rows.")

# Equivalent in GISDK
# table_name = OpenTable("airports", "ffb", {folder + "airports.bin"}, )
# num_rows = GetRecordCount(table_name, )
# ShowMessage("The table '" + table_name + "' has " + String(num_rows) + " rows.")
```

The code above introduces two other important differences:

  * Use a `list` in R when you would use an `array` in GISDK.
  * Use `NA` in R when you would use `null` in GISDK.

To improve integration with R, some GISDK functions have been implemented
directly in the `caliper` package:

  * `RunMacro()` ([example 1](#ex1))
  * `SetAlternateInterface()` ([example 3](#ex3))
  * `GetInterface()` ([example 3](#ex3))
  * `CreateObject()` ([example 7](#ex7))

Trying to call these functions using `RunFunction()` will display a helpful
error message:

```{r, error=TRUE}
RunFunction("RunMacro")
```


## Custom Macros

In order to call one of your own GISDK functions from R, it must be compiled
into an interface/UI. The `caliper` package comes with a toy GISDK script and
the compiled version of that script as an example.

```{r}
rsc_file <- system.file("extdata", "gisdk", "testing", "gisdk.rsc", package = "caliper")

# unzip the compiled UI file
zip_file <- system.file("extdata", "gisdk", "testing", "my_ui.zip", package = "caliper")
tempdir <- tempdir()
unzip(zip_file, exdir = tempdir, setTimes = TRUE)
ui_path <- file.path(tempdir, "my_ui.dbd")
```

The toy functions are simple, but illustrate some important points in the
examples below.

### Example 3: First macro {#ex3}

To reference a custom function that you have written and compiled, first use 
`SetAlternateInterface()` to point to your compiled code.

```{r}
SetAlternateInterface(ui_path)
RunMacro("first macro")
```

You can see the current interface using

```{r}
GetInterface()
```

and set it back to the default interface with

```{r}
SetAlternateInterface()
GetInterface()
```

## Named Arrays

### Example 4: Parse opts array

Many GISDK functions and macros take named arrays (aka options arrays) as input.
`caliper` allows you to pass named lists as an equivalent.

```{r}
SetAlternateInterface(ui_path)

opts <- list()
opts$one <- 1
opts$two <- 2
RunMacro("parse opts array", opts)
```

## Message Boxes

### Example 5: Show array

If you call a macro that uses `ShowMessage()`, `ShowArray()` or something
similar, R will wait until you have closed that pop up before continuing. You
can test the behavior by running the code below. You may have to alt-tab to find
the pop up window.

```{r, eval=FALSE}
RunMacro("show array", opts)
```

## Advanced

### Example 6: Matrices

Before getting started, I create a temporary copy of the package's matrixfile. 
This is only to ensure that changes made by this script are not made to the
original version.

```{r}
orig <- system.file(
  "extdata", "gisdk", "testing", "toy_matrix.mtx", package = "caliper"
)
mtx_file <- tempfile(fileext = ".mtx")
file.copy(orig, mtx_file)
```

Working with matrices in R has been streamlined. Opening a matrix, for example,
returns an object with several useful attributes and methods.

```{r}
mtx <- RunFunction("OpenMatrix", mtx_file, NA)
```

Several generic functions can be used on the resulting R6 object.

```{r}
summary(mtx)
```

```{r}
tbl <- as.data.frame(mtx)
head(tbl)
```

The function `as.matrix` can be used on a specific core, or on the matrix object
directly to convert all cores.

```{r}
as.matrix(mtx$core_b)
as.matrix(mtx)
```

You can also send updated data back to Caliper software. In the code below, I
update the top left corner of `core_b`.

```{r}
new_data <- matrix(seq(1, 4), nrow = 2, ncol = 2, 
                   dimnames = list(c(1,2), c(1,2)))
mtx$core_b <- new_data
as.matrix(mtx$core_b)
```


#### Row and column indices

Row and column indices allow you to subset caliper matrices. You can which 
indices are availabe for the matrix as shown below.

```{r}
mtx$indices
```

The `row_index` and `column_index` active fields allow you to see which index is
active or switch between available indices. In our example matrix, the `subset`
index only contains the first 3 rows and columns of the full matrix.

First, we can check what the currently-active row index is:

```{r}
mtx$row_index
```

The "all" row index is active, which means all 5 rows. Next, we can change it to 
the "subset" index to only work with the first 3.

```{r}
mtx$row_index <- "subset"
as.matrix(mtx$core_b)
```

Finally, we can do the same to the column index, which gives us a 3x3 matrix.

```{r}
mtx$column_index <- "subset"
as.matrix(mtx$core_b)
```

To support additional work over COM, pointers to the matrix handle and each
currency are also made available. These can be passed into `RunFunction()` and
`RunMacro()` to do further work in Caliper software.

Some examples:

```{r}
# A GISDK function requiring a matrix handle
RunFunction("GetMatrixBaseIndex", mtx$handle)

# A GISDK function requiring a matrix currency
RunFunction("GetMatrixColumnLabels", mtx$core_a)
```

Note that the column labels are only 1-3 as opposed to 1-5. The matrix currency
pointer respects the `subset` column index we set.

### Example 7: GISDK objects {#ex7}

The `caliper` package provides a straightforward approach to managing GISDK
objects over COM.

```{r}
object <- CreateObject("NLM.Model")
```

The only difference between R and GISDK is syntax: R uses `$` instead of `.` to
access object attributes and methods. The code below sets the `Label`
attribute of the `NLM.Model` GISDK object.

```{r}
object$Label <- "A logit model"
object$Label
```

Next, the `Clear()` method of the `NLM.Model` object is called, which removes
the value of all fields including `Label`.

```{r}
object$Clear() 
object$Label
```

To see the complete list of available fields and methods for the GISDK object,
simply use `object$info`.

```{r}
info <- object$info
head(info$FieldNames)
head(info$MethodNames)
```

### Example 8: Views in R

Caliper software represents tabular data in "views". Earlier examples showed
how to use `RunFunction()` to open a view and get the number of rows using
GISDK functions. It can also be helpful to bring that tabular data into R for
additional processing. Two functions exist to help with this:

  * `view_to_df()`: convert a Caliper view into an R data frame
  * `df_to_view()`: convert a data frame into a Caliper view

In the code below, a data.frame is sent to a view. A new view is created, and
it's name is returned.
  
```{r}
df <- data.frame("one" = c(1, 2), "two" = c(3, 4), "three" = c(5, 6))
df
view <- df_to_view(df)
view
```
  
GISDK functions will now operate on that view as seen in previous examples.

```{r}
RunFunction("GetRecordCount", view, NA)
```

The view can be brought back into a new data.frame.

```{r}
df2 <- view_to_df(view)
df2
```

Finally, the view can be updated with new data. This time, we include the name
of the view we want to update.

```{r}
df2$one <- 10
view <- df_to_view(df2, view)
view_to_df(view)
```

