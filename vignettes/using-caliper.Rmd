---
title: "Using caliper"
author: "Kyle Ward"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Using caliper}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

`caliper` makes it easy to work with Caliper software from R. Supported
software includes:

  * [TransCAD](https://www.caliper.com/tcovu.htm)
  * [TransModeler](https://www.caliper.com/transmodeler/default.htm)
  * [Maptitude](https://www.caliper.com/maptovu.htm)

The sections below show how to work with the package.

## Connecting

When you load the library, `caliper` will automatically find and connect to
installed Caliper software.

```{r}
library(caliper)
```

It does so using the `connect()` function. If you have multiple
software applications installed, you can call this directly to specify which you
want to connect to.

```{r}
# connect("Maptitude")
```

To close the connection (and the caliper software running in the background),
use `disconnect()`.

## Basic Macros/Functions

Caliper software comes with a scripting language called GISDK. In this language,
there is a differentiation between 'functions' and 'macros'. Functions are
written in C++ and are called directly in GISDK (e.g. `OpenTable()'). Macros are
written in GISDK, and are called using `RunMacro("macro name")'.

### Example 1: Running a macro {#ex1}

```{r}
folder <- RunMacro("G30 Tutorial Folder")
folder
```

This is the equivalent of writing `RunMacro("G30 Tutorial Folder")` in GISDK.

### Example 2: Running a function

To run a function from R, the format is slightly different from GISDK. Instead
of calling `OpenTable()` directly, use `RunFunction("OpenTable")`.

```{r}
table_name <- RunFunction("OpenTable", "airports", "ffb", list(paste0(folder, "airports.bin"), NA))
num_rows <- RunFunction("GetRecordCount", table_name, NA)
paste0("The table '", table_name, "' has ", num_rows, " rows.")

# Equivalent in GISDK
# table_name = OpenTable("airports", "ffb", {folder + "airports.bin"}, )
# num_rows = GetRecordCount(table_name, )
# ShowMessage("The table '" + table_name + "' has " + String(num_rows) + " rows.")
```

The code above shows introduces two other important ideas:

  * Use a `list` in R when you would use an `array` in GISDK.
  * Use `NA` in R when you would use `null` in GISDK.

To improve integration with R, some GISDK functions have been implemented
directly in the `caliper` package:

  * `RunMacro()` ([example 1](#ex1))
  * `SetAlternateInterface()` ([example 3](#ex3))
  * `GetInterface()` ([example 3](#ex3))
  * `CreateObject()` ([example 7](#ex7))

Trying to call these functions using `RunFunction()` will display a helpful
error message:

```{r, error=TRUE}
RunFunction("RunMacro")
```


## Custom Macros

In order to call one of your own GISDK functions from R, it must be compiled
into an interface/UI. The `caliper` package comes with a toy GISDK script and
the compiled version of that script as an example.

```{r}
rsc_file <- system.file("extdata", "gisdk", "gisdk.rsc", package = "caliper")

# unzip the compiled UI file
zip_file <- system.file("extdata", "gisdk", "my_ui.zip", package = "caliper")
tempdir <- tempdir()
unzip(zip_file, exdir = tempdir, setTimes = TRUE)
ui_path <- file.path(tempdir, "my_ui.dbd")
```

The toy functions are simple, but illustrate some important points in the
examples below.

### Example 3: First macro {#ex3}

To reference a custom function that you have written and compiled, first use 
`SetAlternateInterface()` to point to your compiled code.

```{r}
SetAlternateInterface(ui_path)
RunMacro("first macro")
```

You can see the current interface using

```{r}
GetInterface()
```

and set it back to the default interface with

```{r}
SetAlternateInterface()
GetInterface()
```

## Named Arrays

### Example 4: Parse opts array

Many GISDK functions and macros take named arrays (aka options arrays) as input.
`caliper` allows you to pass named lists/vectors as an equivalent.

```{r}
SetAlternateInterface(ui_path)

RunMacro(
  "parse opts array",
  list(
    one = 1,
    two = 2
  )
)
```

## Message Boxes

### Example 5: Show array

If you call a macro that uses `ShowMessage()`, `ShowArray()` or something
similar, R will wait until you have closed that pop up before continuing. You
can test the behavior by running the code below.

```{r, eval=FALSE}
RunMacro(
  "show array",
  list(
    one = 1,
    two = 2
  )
)
```

## Advanced

### Example 6: Matrices

Working with matrices in R has been streamlined. Opening a matrix, for example,
returns an object with several useful attributes and features.

```{r}
file <- system.file("extdata", "gisdk", "toy_matrix.mtx", package = "caliper")
matrix <- RunFunction("OpenMatrix", file, NA)
```

Several generic functions can be used on the resulting R6 object.

```{r}
summary(matrix)
```

```{r}
tbl <- as.data.frame(matrix)
head(tbl)
```

```{r}
as.matrix(matrix, core = "core b")
```

You can see the various row and column indices defined in the matrix.

```{r}
matrix$indices
```

The `row_index` and `column_index` active fields allow you to see which index
is active or switch between available indices. The `subset` index only contains
the first 3 rows and columns of the full matrix.

```{r}
matrix$row_index
matrix$row_index <- "subset"
as.matrix(matrix, core = "core b")
matrix$column_index <- "subset"
as.matrix(matrix, core = "core b")
```

To support additional work over COM, pointers to the matrix handle and each
currency are also made available. These can be passed into `RunFunction()` and
`RunMacro()` to do further work in Caliper software.

```{r}
# Points to the Caliper matrix handle
matrix$handle

# Points to a matrix currency
matrix$cores$`core a`
```

Some examples:

```{r}
RunFunction("GetMatrixBaseIndex", matrix$handle)
RunFunction("GetMatrixColumnLabels", matrix$cores$`core a`)
```

Note that the column labels are only 1-3 as opposed to 1-5. The matrix currency
pointer is also using the `subset` index we set.

### Example 7: GISDK objects {#ex7}

The `caliper` package provides a straightforward approach to managing GISDK
objects over COM.

```{r}
object <- CreateObject("NLM.Model")
```

The only difference between R and GISDK is syntax: R uses `$` instead of `.` to
access object attributes and methods. The code below sets the `Label`
attribute of the `NLM.Model` GISDK object.

```{r}
object$Label <- "A logit model"
object$Label
```

Next, the `Clear()` method of the `NLM.Model` object is called, which removes
the value of all fields including `Label`.

```{r}
object$Clear() 
object$Label
```

To see the complete list of available fields and methods for the GISDK object,
simply use `object$info`.

```{r}
info <- object$info
head(info$FieldNames)
head(info$MethodNames)
```
