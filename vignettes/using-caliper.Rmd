---
title: "Using caliper"
author: "Kyle Ward"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Using caliper}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

`caliper` makes it easy to work with Caliper software from R. Supported
software includes:

  * [TransCAD](https://www.caliper.com/tcovu.htm)
  * [TransModeler](https://www.caliper.com/transmodeler/default.htm)
  * [Maptitude](https://www.caliper.com/maptovu.htm)

The sections below show how to work with the package.

## Connecting

When you load the library, it will automatically find and connect to installed
Caliper software.

```{r}
library(caliper)
```

It does so using the `caliper::connect()` function. If you have multiple
software applications installed, you can call this directly to specify which you
want to connect to.

```{r}
# connect("Maptitude")
```

## Basic Macros

Caliper software comes with a scripting language called GISDK. In this language,
functions are referred to as "macros". Running one from R with `caliper` is as
simple as calling `run_macro()`.

### Example 1

```{r}
folder <- RunMacro("G30 Tutorial Folder")
folder
```

This is the equivalent of writing `RunMacro("G30 Tutorial Folder")` in GISDK.
The change from `RunMacro` to `run_macro` is to conform to the [R style
guide](https://style.tidyverse.org/index.html) by Hadley Wickham.

### Example 2

The code block below introduces two important ideas:

  * Use a `list` in R when you would use an `array` in GISDK.
  * Use `NA` in R when you would use `null` in GISDK.

```{r}
table_name <- RunFunction("OpenTable", "airports", "ffb", list(paste0(folder, "airports.bin"), NA))
num_rows <- RunFunction("GetRecordCount", table_name, NA)
paste0("The table '", table_name, "' has ", num_rows, " rows.")

# Equivalent in GISDK
# table_name = OpenTable("airports", "ffb", {folder + "airports.bin"}, )
# num_rows = GetRecordCount(table_name, )
# ShowMessage("The table '" + table_name + "' has " + String(num_rows) + " rows.")
```

## Custom Macros

If you were paying close attention in the first two examples, you may have
noticed that `caliper::run_macro()` determined that `"G30 Tutorial Folder"`
should be called using GISDKs `RunMacro("G30 Tutorial Folder")` while
`"OpenTable"` should be called using `OpenTable()`. The same internal logic
makes it easy to use `run_macro()` to call your own functions.

In order to call one of your own functions from R, it must be compiled into a
UI. The `caliper` package comes with a toy GISDK script and the compiled
version of that script (zipped). The toy UI must be unzipped, which adds a few
lines of code in the block below. The important variable is `ui_path`, which
needs to poin to your compiled UI file (.dbd).

```{r}
rsc_file <- system.file("extdata", "gisdk", "gisdk.rsc", package = "caliper")
zip_file <- system.file("extdata", "gisdk", "my_ui.zip", package = "caliper")
tempdir <- tempdir()
unzip(zip_file, exdir = tempdir)

ui_path <- file.path(tempdir, "my_ui.dbd")
```

The provided functions are simple, but illustrate some important points.

### Example 3

To reference a custom function that you have written and compiled, first use 
`SetAlternateInterface()` as shown below.

```{r}
SetAlternateInterface(ui_path)
RunMacro("first macro")
```

You can see the current interface using

```{r}
GetInterface()
```

and set it back to the default interface with

```{r}
SetAlternateInterface()

# to check
GetInterface()
```

## Named Arrays

### Example 4

Many GISDK functions take named arrays (aka options arrays) as input. `caliper` allows you to pass named lists/vectors as an equivalent.

```{r}
SetAlternateInterface(ui_path)

RunMacro(
  "parse opts array",
  list(
    one = 1,
    two = 2
  )
)
```

## Message Boxes

### Example 5

If you call a macro that uses `ShowMessage()`, `ShowArray()` or something
similar, R will wait until you have closed that pop up before continuing. You
can test the behavior by running the code below.

```{r, eval=FALSE}
RunMacro(
  "show array",
  list(
    one = 1,
    two = 2
  )
)
```

## Limitations

### Returned values

Sending data from R -> GISDK works well; however, data from GISDK -> R currently
has some limitations. The code block below gives a snippet of what the GISDK is
returning, and shows what it looks like in R.

  * Arrays and vectors are returned as vectors
  * Nested arrays are returned as flattened vectors
  * Named/Options arrays are returned as nested lists

```{r}
# return({1, 2})
str(RunMacro("return array"))

# return(A2V({1, 2}))
str(RunMacro("return vector"))

# return({{1, 2}, {3, 4}})
str(RunMacro("return nested array"))

# return({{"one", 1}, {"two", 2}})
str(RunMacro("return named array"))
```

### Error messages

`caliper` uses [COM](https://en.wikipedia.org/wiki/Component_Object_Model) to
communicate between R and Caliper software. In general, the error messages
returned aren't helpful.

## Recommended use of caliper

Given the limitations above, the most effective use of `caliper` is as a
wrapper. It can be used to call the GISDK macros that make up a model. Better
yet, it can call a control macro that in turn calls all the macros, handles
feedback, etc.

In addition, small, custom UIs can be created to perform specific tasks. For
instance, an R program might have need of the skim routines in TransCAD. A small
macro can be written in GISDK to perform the skim and write the results out to a
CSV file that R can then read. This can be called directly from R using
`caliper` to streamline the application.
