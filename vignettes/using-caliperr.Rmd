---
title: "Using caliperr"
author: "Kyle Ward"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using caliperr}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

`caliperr` makes it easy to work with Caliper software from R.

  * [TransCAD](https://www.caliper.com/tcovu.htm)
  * [TransModeler](https://www.caliper.com/transmodeler/default.htm)
  * [Maptitude](https://www.caliper.com/maptovu.htm)

The examples below show how to work with the package.

## Connecting

When you load the library, it will automatically find and connect to installed
Caliper software.

```{r}
library(caliperr)
```

It does so using the `caliperr::connect()` function. If you have multiple
software applications installed, you can call this directly to specify which you
want to connect to.

```{r}
# connect("Maptitude")
```

## Basic Macros

Caliper software comes with a scripting language called GISDK. In this language,
functions are referred to as "macros". Running one from R with `caliperr` is as
simple as calling `run_macro()`.

### Example 1

```{r}
folder <- run_macro("G30 Tutorial Folder")
folder
```

This is the equivalent of writing `RunMacro("G30 Tutorial Folder")` in GISDK.
The change from `RunMacro` to `run_macro` is to conform to the [R style
guide](https://style.tidyverse.org/index.html) created by Hadley Wickham.

### Example 2

The code block below introduces two important ideas:

  * Use a `list` in R when you would use an `array` in GISDK.
  * Use `NA` in R when you would use `null` in GISDK.

```{r}
table_name = run_macro(
  "OpenTable", "airports", "ffb", list(paste0(folder, "airports.bin"), NA)
)
num_rows = run_macro("GetRecordCount", table_name, NA)
paste0("The table '", table_name, "' has ", num_rows, " rows.")

# Equivalent in GISDK
# table_name = OpenTable("airports", "ffb", {folder + "airports.bin"}, )
# num_rows = GetRecordCount(table_name, )
# ShowMessage(
#   "The table '" + table_name + "' has " + String(num_rows) + " rows."
# )
```

## Custom Macros

If you were paying close attention in the first two examples, you may have
noticed that `caliperr::run_macro()` determined that `"G30 Tutorial Folder"`
should be called using GISDKs `RunMacro("G30 Tutorial Folder")` while
`"OpenTable"` should be called using `OpenTable()`. This makes it easy to use
`run_macro()` to call your own functions.

The `caliperr` package comes with a toy GISDK script and the compiled version of
that script. In order to call one of your own functions from R, it must be
compiled into a UI. The provided functions are simple, but illustrate some
important points.

```{r}
rsc_file <- system.file("extdata", "gisdk", "gisdk.rsc", package = "caliperr")
ui_path <- system.file("extdata", "gisdk", "my_ui.dbd", package = "caliperr")
```

### Example 3

To reference a custom function that you have written and compiled, include the
named argument `ui` in the call and point it to your compiled UI.

```{r}
run_macro("first macro", ui = ui_path)
```

### Example 4

As a convenience, you can change the default UI of the package using
`set_caliper_ui()`. This is done simply to avoid having to provide the `ui`
argument to multiple function calls if they are all using a custom UI. You can
call it again to return to the package default.

```{r}
set_caliper_ui(ui_path)
run_macro("add", 5, 6)
run_macro("add", "a", "b")
set_caliper_ui()
```

## Named Arrays

Many GISDK functions take named arrays (aka options arrays) as input. `caliperr` allows you to pass named lists/vectors as an equivalent.

```{r}
run_macro(
  "parse opts array",
  ui = ui_path,
  list(
    one = 1,
    two = 2
  )
)
```


















Vignettes are long form documentation commonly included in packages. Because they are part of the distribution of the package, they need to be as compact as possible. The `html_vignette` output type provides a custom style sheet (and tweaks some options) to ensure that the resulting html is as small as possible. The `html_vignette` format:

- Never uses retina figures
- Has a smaller default figure size
- Uses a custom CSS stylesheet instead of the default Twitter Bootstrap style

## Vignette Info

Note the various macros within the `vignette` section of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
