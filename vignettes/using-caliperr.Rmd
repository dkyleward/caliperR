---
title: "Using caliperr"
author: "Kyle Ward"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Using caliperr}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

`caliperr` makes it easy to work with Caliper software from R. Supported
software includes:

  * [TransCAD](https://www.caliper.com/tcovu.htm)
  * [TransModeler](https://www.caliper.com/transmodeler/default.htm)
  * [Maptitude](https://www.caliper.com/maptovu.htm)

The sections below show how to work with the package.

## Connecting

When you load the library, it will automatically find and connect to installed
Caliper software.

```{r}
library(caliperr)
```

It does so using the `caliperr::connect()` function. If you have multiple
software applications installed, you can call this directly to specify which you
want to connect to.

```{r}
# connect("Maptitude")
```

## Basic Macros

Caliper software comes with a scripting language called GISDK. In this language,
functions are referred to as "macros". Running one from R with `caliperr` is as
simple as calling `run_macro()`.

### Example 1

```{r}
folder <- run_macro("G30 Tutorial Folder")
folder
```

This is the equivalent of writing `RunMacro("G30 Tutorial Folder")` in GISDK.
The change from `RunMacro` to `run_macro` is to conform to the [R style
guide](https://style.tidyverse.org/index.html) by Hadley Wickham.

### Example 2

The code block below introduces two important ideas:

  * Use a `list` in R when you would use an `array` in GISDK.
  * Use `NA` in R when you would use `null` in GISDK.

```{r}
table_name <- run_macro("OpenTable", "airports", "ffb", list(paste0(folder, "airports.bin"), NA))
num_rows <- run_macro("GetRecordCount", table_name, NA)
paste0("The table '", table_name, "' has ", num_rows, " rows.")

# Equivalent in GISDK
# table_name = OpenTable("airports", "ffb", {folder + "airports.bin"}, )
# num_rows = GetRecordCount(table_name, )
# ShowMessage("The table '" + table_name + "' has " + String(num_rows) + " rows.")
```

## Custom Macros

If you were paying close attention in the first two examples, you may have
noticed that `caliperr::run_macro()` determined that `"G30 Tutorial Folder"`
should be called using GISDKs `RunMacro("G30 Tutorial Folder")` while
`"OpenTable"` should be called using `OpenTable()`. The same internal logic
makes it easy to use `run_macro()` to call your own functions.

In order to call one of your own functions from R, it must be compiled into a
UI. The `caliperr` package comes with a toy GISDK script and the compiled
version of that script. 

```{r}
rsc_file <- system.file("extdata", "gisdk", "gisdk.rsc", package = "caliperr")
ui_path <- system.file("extdata", "gisdk", "my_ui.dbd", package = "caliperr")
```

The provided functions are simple, but illustrate some important points.

### Example 3

To reference a custom function that you have written and compiled, include the
named argument `ui` in the call and point it to your compiled UI.

```{r}
run_macro("first macro", ui = ui_path)
```

### Example 4

As a convenience, you can change the default UI of the package using
`set_caliper_ui()`. This is done simply to avoid having to provide the `ui`
argument to multiple function calls if they are all using the same custom UI.
You can call it again to return to Caliper's default.

```{r}
set_caliper_ui(ui_path)
run_macro("add", 5, 6)
run_macro("add", "a", "b")
set_caliper_ui()
```

## Named Arrays

### Example 5

Many GISDK functions take named arrays (aka options arrays) as input. `caliperr` allows you to pass named lists/vectors as an equivalent.

```{r}
run_macro(
  "parse opts array",
  ui = ui_path,
  list(
    one = 1,
    two = 2
  )
)
```

## Message Boxes

### Example 6

If you call a macro that uses `ShowMessage()`, `ShowArray()` or something
similar, R will wait until you have closed that pop up before continuing. You
can test the behavior by running the code below.

```{r, eval=FALSE}
run_macro(
  "show array",
  ui = ui_path,
  list(
    one = 1,
    two = 2
  )
)
```

## Limitations

### Returned values

Sending data from R -> GISDK works well; however, data from GISDK -> R currently
has some limitations. The code block below gives a snippet of what the GISDK is
returning, and shows what it looks like in R.

  * Arrays are returned as vectors
  * Nested arrays are returned as flattened vectors
  * Named/Options arrays are returned as nested lists
  * Vectors are returned as an unusable formal class

```{r}
# return({1, 2})
str(run_macro("return array", ui = ui_path))

# return({{1, 2}, {3, 4}})
str(run_macro("return nested array", ui = ui_path))

# return({{"one", 1}, {"two", 2}})
str(run_macro("return named array", ui = ui_path))

# return(A2V({1, 2}))
str(run_macro("return vector", ui = ui_path))
```

### Error messages

`caliperr` uses [COM](https://en.wikipedia.org/wiki/Component_Object_Model) to
communicate between R and Caliper software. In general, the error messages
returned aren't helpful.

## Recommended use of caliperr

Given the limitations above, the most effective use of `caliperr` is as a
wrapper. It can be used to call the GISDK macros that make up a model. Better
yet, it can call a control macro that in turn calls all the macros, handles
feedback, etc.

In addition, small, custom UIs can be created to perform specific tasks. For
instance, an R program might have need of the skim routines in TransCAD. A small
macro can be written in GISDK to perform the skim and write the results out to a
CSV file that R can then read. This can be called directly from R using
`caliperr` to streamline the application.
